je voudrais réécrire le parser com.protectline.jsproject.parser.JsProjectParser : le but c'est de faire passer com.protectline.jsproject.JsProjectParserTest.should_parse_js_file
Mon idée serait la suivante, dans les resources il y a les templates sous forme de json src/test/resources/tobpmn/jsupdatertemplates/jsupdatertemplates.json
Il faudrait utiliser chaque entrée dans l'ordre donc d'abord Main, ensuite Function
Pour chaque entrée, extraire grâce au champ "element" toutes les balises <{element} > <{element}/> et en faire un objet qui aurait une map de tous les ids, plus le contenu
enfant sous forme de String.
pour chacun de ses éléments, grâce à une factory qui se base sur "element" pour constuire un nouveau parser (cf inteface JsParser), parser le contenu pour en sortir :
à la fois les strings qui resteraient à parser, les blocs ainsi constitué.
Pour les strings qui restent à parser on peut les ré injecter dans la boucle principale (il va y avoir de la récursivité j'imagine), pour les blocs constitués on peut les ajouter à une liste qui accumule tous les blocs
construits.

Par exemple le Main parser ne constituera aucun bloc mais renverra l'intégralité de son contenu en string à la boucle principale.
Ensuite on va tomber sur des //<function ... qui seront interpretté comme des choses à parser, puis grâce au parsing de l'element (ici "function") on va passer
toute  ce qui est entre les balises function (plus les attributs, ici id) au parser FunctionParser qui va, grâce au template, constuire l'object Block, avec son id, non name et son content
comme il n'y a pas d'autre balise dans le content, la sortie est uniquement le Block créé et pas de string, donc on ne rappel pas la boucle principal.

Ce qu'il y a retenir :
le partie à parsé sont définis par des balises types xml, en commentaire dans le fichier js
grâce à ces pseudo balises on peut créer le bon parser et lui transmettre les bons éléments (attributs, et contenut)
grâce au template on parse le contenu et on créé le ou les blocs qu'il faut, si on tombe sur d'autre balise dans le contenu on continue de parser.

Une idée serait que le retour de la boucle principale soit lui même un parser et qu'il renvois une string avec juste le contenu s'il ne tombe sur aucune balise.
Du coup, le parsing du contenu d'une balise se d'abord par passer le contenu de la balise à la boucle principale, puis à parser la string renvoyer par la boucle principale.

1. Structure des balises : Je vois dans le fichier JS des balises comme //<function
  id=435ec209-a46a-47b3-809a-fe263f4133a0> et //<function/>. Est-ce que le parser doit extraire l'attribut id et l'associer
   au contenu entre les balises ?

 réponse : les attributs sont nécessaires pour construires les blocks (ils sont donc à passer au parser sous forme de Map<String, String>

  2. Template MAIN : Le template MAIN contient //<FUNCTIONS> - cela signifie que quand le MainParser trouve cette balise,
  il doit la remplacer par l'ensemble des fonctions parsées ?

 réponse : le champ template sert à deux choses, au moment de crééer le projet (en dehors du scope de ce que nous faisons ici, cette fonctionalité fonctionne
 donc on ne peut pas changer le champ template) et au moment de parser le projet. Au moment de créer le projet, on va chercher le "flag" et le remplacer par le "template"
 C'est à ce moment là que //<FUNCTIONS> est util. Ici on s'occupe du parsing : il faut donc prendre uniquement en compte ce qui est entre "**" et ignore les autres balises qui seraient dans les templates
 (par exemple ici //<FUNCTIONS> est considéré comme une balise à l'intérieur du template de main, donc à ignorer

  3. Récursivité : Quand vous mentionnez que le contenu d'une fonction peut contenir d'autres balises à parser - avez-vous
  des exemples concrets dans votre codebase, ou c'est pour des cas futurs ?

réponse : pour des cas futurs.
mais je peux donner un exemple :
//<function id=230>
uneFonction(){
let a = 3;
//<balise>
let b= 4;
//<balise/>
}
//<function/>
ici le parsing se fait en plusieurs étages :
1 : on repère une balise, on extrait l'élément : function
2 : grâce à une factory on créé un FunctionParser auquel on lui donne :
    - Map attribut : { "id" : "230"}
    - contenu :
uneFonction(){
let a = 3;
//<balise>
let b= 4;
//<balise/>
}
3 : le contenu est ré injecté dans la boucle, le parser parse le texte tel quel et parse l'élément balise, créant ainsi le blocks Balise, il renvois donc
    - une string : "uneFonction(){
    let a= 3;
    }"
    - un block Balise

4 : le contenu est ensuite parsé selon le template: on extrait le name et le content

Du coup je pense qu'on pourra changer le type de retour du parser, pas la peine de retourner une liste de String et une liste de blocks,
juste la liste des blocks et une seule string correspondant à la string, éxtraite de tout block interne

  4. Comptage des blocs : Le test attend 20 blocs. En comptant dans le fichier JS, je vois effectivement environ 20
  fonctions entre balises function. C'est bien ça ?

oui c'est bien ça

  5. Interface JsParser : Vous voulez que chaque parser (Main, Function) retourne à la fois des Block objects et des String
   à re-parser ?
déjà répondu plus haut
